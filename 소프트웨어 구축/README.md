### 애플리케이션 테스트 기본 원리 - 1회 (2020 1회차)
애플리케이션 테스트는 소프트웨어의 **잠재적인 결함을 줄일 수 있지만** 소프트웨어에 **결함이 없다고 보장할 수는 없다.** 즉 **완벽한 소프트웨어 테스팅은 불가능하다.**
* 파레토 법칙: 애플리케이션의 **20%에 해당하는 코드에서 80%의 결함이 발견된다.**
* `살충제 패러독스*`: **동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 현상** 이다. 즉, **테스트 케이스를 다양하게 작성해야 한다.**
* 오류-부재의 궤변: 결함이 없다 해도 사용자의 요구사항 미충족 시 품질 저하

## 6. 소프트웨어 유지 보수

### 애플리케이션 성능 개선
| 지표                | 설명                                                         |
:--------------------|:-----------------------------------------------------------|
| `처리량(Throughput)*`   | 일정 시간 내에 애플리케이션이 처리하는 일의 양                                 |
| `응답 시간(Response Time)*` | 애플리케이션에 요청을 전달한 시간부터 응답이 도착할 떄까지 걸린 시간                     |
| `경과 시간(Turnaround Time)*` | 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 떄까지 걸린 시간                     |
| `자원 사용률(Resource Utilization)*` | 애플리케이션이 의뢰한 작업을 처리하는 동안의 CPU 사용량 메모리 사용량 네트워크 사용량 등 자원 사용률 |

### 소스 코드 품질 분석 도구
1. 정적 분석 도구: **프로그램을 실행하지 않고 소스 코드의 구조를 분석하여 결함을 찾아내는 도구**
2. 동적 분석 도구: **프로그램을 실행하면서 동작을 분석하여 결함을 찾아내는 도구**

## 4. 소프트웨어 구현
### 디자인 패턴
* GoF(Gang of Four) 디자인 패턴: 객체 지향 프로그래밍에서 자주 발생하는 문제를 해결하기 위한 재사용 가능한 솔루션

#### 생성 패턴
| 패턴 이름          | 설명                                                                                                            |
|--------------------|---------------------------------------------------------------------------------------------------------------|
| Abstract Factory  | 1. 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관 의존 하는 객체들의 그룹으로 생성하여 추상적으로 표현함 <br/> 2.연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능함 |
| Builder | 1. 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성함 <br/> 2. 객체의 생성 과정과 표현 방법을 분리하고 있어 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있음      |
| Factory Method | 1. 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴 <br/> 2. 상위 클래스에서 인터페이스만 정의 하고 실제 생성은 서브 클래스가 담당                        |
| Prototype | 1. 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴 <br/> 2. 일반적인 방법으로 객체를 생성하며 비용이 큰 경우 주로 이용함                                   
| Singleton | 1. 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만 여러 프로세스가 동시에 참조할 수는 없음 <br/> 2. 클래스 내에서 인스턴스가 하나뿐임을 보장                 |

#### 구조 패턴
| 패턴 이름       | 설명                                                                                                           |
|-------------|--------------------------------------------------------------------------------------------------------------|
| Adapter     | 1. 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용 할 수 있도록 변환하는 패턴 <br/> 2. 기존의 클래스를 이용하고 싶지만 인터페이스가 일치 하지 않을 떄 사용 |
| Bridge(브리지) | 1. 구현부에서 추상층을 분리하여, 서로 독립적으로 확장할 수 있도록 구성한 패턴 <br/> 2. 기능과 구현을 두 개의 별도 클래스로 구현함 |
| Composite(컴포지트) | 1. 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 떄 사용하는 패턴 <br/> 2. 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있음 |
| Decorator(데코레이터) | 1. 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴 <br/> 2. 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현 |
| Facade(퍼사드) | 1. 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴 <br/> 2. 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요함 |
| Flyweight(플라이웨이트) | 1. 인스턴스가 필요할 떄마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴 <br/> 2. 다수의 유사 객체를 생성하거나 조작할 떄 유용하게 사용할 수 있음 |
| Proxy(프록시) | 1. 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴 <br/> 2. 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용함 |